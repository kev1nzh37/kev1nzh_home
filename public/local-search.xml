<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vite 依赖解析和预构建 源码分析 - (1)代码入口</title>
    <link href="/2021/07/14/vite-1/"/>
    <url>/2021/07/14/vite-1/</url>
    
    <content type="html"><![CDATA[<h1 id="Vite-依赖解析和预构建-源码分析-1-代码入口"><a href="#Vite-依赖解析和预构建-源码分析-1-代码入口" class="headerlink" title="Vite 依赖解析和预构建 源码分析 - (1)代码入口"></a>Vite 依赖解析和预构建 源码分析 - (1)代码入口</h1><h4 id="Server-listen"><a href="#Server-listen" class="headerlink" title="Server.listen"></a>Server.listen</h4><p>在 cli.ts 文件中，接收命令行的运行参数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 命令行输入命令启动vite</span><br>npm run dev<br><span class="hljs-comment">// 根据package调用vite并获取命令参数 如--force build...</span><br>vite xxxx xxx xxx<br></code></pre></td></tr></table></figure><p>vite 运行的第一步，获取命令参数，最后创建 server 并运行 listen 函数。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//cli.ts</span><br><br>.action(<span class="hljs-keyword">async</span> (root: <span class="hljs-built_in">string</span>, <span class="hljs-attr">options</span>: ServerOptions &amp; GlobalCLIOptions) =&gt; &#123;<br>        <span class="hljs-keyword">const</span> &#123; createServer &#125; = <span class="hljs-keyword">await</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./server&#x27;</span>)<br>        <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">const</span> server = <span class="hljs-keyword">await</span> createServer(&#123;<br>                ...<br>                &#125;)<br>                <span class="hljs-keyword">await</span> server.listen()<br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>                ...<br>        &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>listen 函数中，runOptimize 函数就是预构建的核心代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// server/index.ts =&gt; listen</span><br><span class="hljs-keyword">if</span> (!middlewareMode &amp;&amp; httpServer) &#123;<br>  <span class="hljs-comment">// overwrite listen to run optimizer before server start</span><br>  <span class="hljs-keyword">const</span> listen = httpServer.listen.bind(httpServer);<br>  httpServer.listen = (<span class="hljs-keyword">async</span> (port: <span class="hljs-built_in">number</span>, ...args: <span class="hljs-built_in">any</span>[]) =&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">await</span> container.buildStart(&#123;&#125;);<br>      <span class="hljs-keyword">await</span> runOptimize();<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      httpServer.emit(<span class="hljs-string">&#x27;error&#x27;</span>, e);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> listen(port, ...args);<br>  &#125;) <span class="hljs-keyword">as</span> <span class="hljs-built_in">any</span>;<br>  ...<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">await</span> container.buildStart(&#123;&#125;);<br>  <span class="hljs-keyword">await</span> runOptimize();<br>&#125;<br><br><span class="hljs-comment">// server/index.ts</span><br><span class="hljs-keyword">import</span> &#123; DepOptimizationMetadata, optimizeDeps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../optimizer&#x27;</span><br><br><span class="hljs-keyword">const</span> runOptimize = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (config.cacheDir) &#123;<br>    server._isRunningOptimizer = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      server._optimizeDepsMetadata = <span class="hljs-keyword">await</span> optimizeDeps(config);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      server._isRunningOptimizer = <span class="hljs-literal">false</span>;<br>    &#125;<br>    server._registerMissingImport = createMissingImporterRegisterFn(server);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// server/index.ts</span><br><span class="hljs-keyword">import</span> &#123; DepOptimizationMetadata, optimizeDeps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../optimizer&#x27;</span>;<br><br><span class="hljs-keyword">const</span> runOptimize = <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-keyword">if</span> (config.cacheDir) &#123;<br>    server._isRunningOptimizer = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      server._optimizeDepsMetadata = <span class="hljs-keyword">await</span> optimizeDeps(config);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      server._isRunningOptimizer = <span class="hljs-literal">false</span>;<br>    &#125;<br>    server._registerMissingImport = createMissingImporterRegisterFn(server);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>入口代码很简单，获取了 vite 命令行参数后，创建内部 server，触发各个功能的构建。</p><p>接下来进入详解 optimizeDeps 的章节。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工程化</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite 依赖解析和预构建 源码分析 - (2)预构建对象和前期准备</title>
    <link href="/2021/07/14/vite-2/"/>
    <url>/2021/07/14/vite-2/</url>
    
    <content type="html"><![CDATA[<h1 id="Vite-依赖解析和预构建-源码分析-2-预构建对象和前期准备"><a href="#Vite-依赖解析和预构建-源码分析-2-预构建对象和前期准备" class="headerlink" title="Vite 依赖解析和预构建 源码分析 - (2)预构建对象和前期准备"></a>Vite 依赖解析和预构建 源码分析 - (2)预构建对象和前期准备</h1><h2 id="预构建对象和前期准备"><a href="#预构建对象和前期准备" class="headerlink" title="预构建对象和前期准备"></a>预构建对象和前期准备</h2><p>首先获取预缓存(metadata.json)的路径，以及预构建的 hash 值，以便后续比对。</p><p>这个 json 文件为 vite 处理后导出的数据信息，当此文件存在时，会比对 hash 值，如果相同就会直接读取此文件中的依赖。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer.ts</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">optimizeDeps</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  config: ResolvedConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">  force = config.server.force,</span></span><br><span class="hljs-params"><span class="hljs-function">  asCommand = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  newDeps?: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; root, logger, cacheDir &#125; = config<br>   <span class="hljs-comment">// 这边第三个args为 asCommand, 是否是命令行运行的</span><br>   <span class="hljs-comment">// 为了讲述的流畅性，在上一章节代码入口没有提到， 在vite --force 后，会直接运行optimizeDeps函数，因此需要区分log的输出方式</span><br>   <span class="hljs-comment">// vite --force    =&gt;    await optimizeDeps(config, options.force, true)</span><br>  <span class="hljs-keyword">const</span> log = asCommand ? logger.info : debug<br><br>  <span class="hljs-keyword">if</span> (!cacheDir) &#123;<br>    log(<span class="hljs-string">`No cache directory. Skipping.`</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span><br><br>  <span class="hljs-comment">//这边首先获取 预构建模块路径</span><br>  <span class="hljs-keyword">const</span> dataPath = path.join(cacheDir, <span class="hljs-string">&#x27;_metadata.json&#x27;</span>); <span class="hljs-comment">//预缓存路径</span><br>  <span class="hljs-comment">// /.../my-vue-app/node_modules/.vite/_metadata.json</span><br>  <span class="hljs-keyword">const</span> mainHash = getDepHash(root, config);<br>  <span class="hljs-comment">// 创建一个data的对象，后面会用到</span><br>  <span class="hljs-keyword">const</span> data: DepOptimizationMetadata = &#123;<br>    <span class="hljs-attr">hash</span>: mainHash,<br>    <span class="hljs-attr">browserHash</span>: mainHash,<br>    <span class="hljs-attr">optimized</span>: &#123;&#125;,<br>  &#125;;<br></code></pre></td></tr></table></figure><h3 id="如何获取-hash-值？"><a href="#如何获取-hash-值？" class="headerlink" title="如何获取 hash 值？"></a>如何获取 hash 值？</h3><p>首先获取了预构建模块的路径，默认情况为 node_modules/.vite。</p><p>以下为 metadata.json 的数据结构, 后续会说到。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// node_modules/.vite/_metadata.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;hash&quot;</span>: <span class="hljs-string">&quot;9a4fa980&quot;</span>,<br>  <span class="hljs-attr">&quot;browserHash&quot;</span>: <span class="hljs-string">&quot;6f00d484&quot;</span>,<br>  <span class="hljs-attr">&quot;optimized&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;vue&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;file&quot;</span>: <span class="hljs-string">&quot;/.../my-vue-app/node_modules/.vite/vue.js&quot;</span>,<br>      <span class="hljs-attr">&quot;src&quot;</span>: <span class="hljs-string">&quot;/.../my-vue-app/node_modules/vue/dist/vue.runtime.esm-bundler.js&quot;</span>,<br>      <span class="hljs-attr">&quot;needsInterop&quot;</span>: <span class="hljs-literal">false</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;axios&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;file&quot;</span>: <span class="hljs-string">&quot;/.../new/my-vue-app/node_modules/.vite/axios.js&quot;</span>,<br>      <span class="hljs-attr">&quot;src&quot;</span>: <span class="hljs-string">&quot;/.../new/my-vue-app/node_modules/axios/index.js&quot;</span>,<br>      <span class="hljs-attr">&quot;needsInterop&quot;</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着我们看 getDepHash 函数。<br>官方文档中描述，Vite 在预构建之前，根据以下源来确定是否要重新运行预构建。</p><ul><li>package.json 中的 dependencies 列表</li><li><strong>包管理器的 lockfile，例如 package-lock.json, yarn.lock，或者 pnpm-lock.yaml</strong></li><li>可能在 vite.config.js 相关字段中配置过的</li></ul><p>以下代码中，变量 lockfileFormats 就是包管理器的 locakfile。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer.ts</span><br><span class="hljs-keyword">const</span> lockfileFormats = [<span class="hljs-string">&#x27;package-lock.json&#x27;</span>, <span class="hljs-string">&#x27;yarn.lock&#x27;</span>, <span class="hljs-string">&#x27;pnpm-lock.yaml&#x27;</span>];<br><br><span class="hljs-comment">// /optimizer.ts =&gt; getDepHash</span><br><span class="hljs-keyword">let</span> cachedHash: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDepHash</span>(<span class="hljs-params">root: <span class="hljs-built_in">string</span>, config: ResolvedConfig</span>): <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (cachedHash) &#123;<br>    <span class="hljs-keyword">return</span> cachedHash;<br>  &#125;<br>  <span class="hljs-keyword">let</span> content = lookupFile(root, lockfileFormats) || <span class="hljs-string">&#x27;&#x27;</span>; <span class="hljs-comment">//往下滑会有lookupFile函数的解释。</span><br>  <span class="hljs-comment">// 这边已经获取了所有local file array 内的文件内容</span><br><br>  <span class="hljs-comment">// also take config into account</span><br>  <span class="hljs-comment">// only a subset of config options that can affect dep optimization</span><br><br>  content += <span class="hljs-built_in">JSON</span>.stringify(<br>    &#123;<br>      <span class="hljs-attr">mode</span>: config.mode,<br>      <span class="hljs-attr">root</span>: config.root,<br>      <span class="hljs-attr">resolve</span>: config.resolve,<br>      <span class="hljs-attr">assetsInclude</span>: config.assetsInclude,<br>      <span class="hljs-attr">plugins</span>: config.plugins.map(<span class="hljs-function">(<span class="hljs-params">p</span>) =&gt;</span> p.name),<br>      <span class="hljs-attr">optimizeDeps</span>: &#123;<br>        <span class="hljs-attr">include</span>: config.optimizeDeps?.include, <span class="hljs-comment">// null</span><br>        <span class="hljs-attr">exclude</span>: config.optimizeDeps?.exclude, <span class="hljs-comment">//null</span><br>      &#125;,<br>    &#125;,<br>    <span class="hljs-function">(<span class="hljs-params">_, value</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;function&#x27;</span> || value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>) &#123;<br>        <span class="hljs-keyword">return</span> value.toString();<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>  );<br>  <span class="hljs-comment">//这里不说了  最终返回 &quot;9a4fa980&quot; 八位数hash值。</span><br>  <span class="hljs-keyword">return</span> createHash(<span class="hljs-string">&#x27;sha256&#x27;</span>).update(content).digest(<span class="hljs-string">&#x27;hex&#x27;</span>).substr(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br>&#125;<br><br><span class="hljs-comment">// /optimizer.ts =&gt; lookupFile</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lookupFile</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  dir: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">  formats: <span class="hljs-built_in">string</span>[],</span></span><br><span class="hljs-params"><span class="hljs-function">  pathOnly = <span class="hljs-literal">false</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">string</span> | <span class="hljs-title">undefined</span> </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> format <span class="hljs-keyword">of</span> formats) &#123;<br>    <span class="hljs-keyword">const</span> fullPath = path.join(dir, format); <span class="hljs-comment">//获取root + format路径</span><br>    <span class="hljs-comment">// 路径对象是否存在 并且是文件</span><br>    <span class="hljs-comment">// pathOnly 为true就只返回路径，不然就都默认返回utf-8的文件内容</span><br>    <span class="hljs-keyword">if</span> (fs.existsSync(fullPath) &amp;&amp; fs.statSync(fullPath).isFile()) &#123;<br>      <span class="hljs-keyword">return</span> pathOnly ? fullPath : fs.readFileSync(fullPath, <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> parentDir = path.dirname(dir);<br>  <span class="hljs-keyword">if</span> (parentDir !== dir) &#123;<br>    <span class="hljs-keyword">return</span> lookupFile(parentDir, formats, pathOnly);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="是否强制优化并处理-vite-文件夹"><a href="#是否强制优化并处理-vite-文件夹" class="headerlink" title="是否强制优化并处理.vite 文件夹"></a>是否强制优化并处理.vite 文件夹</h3><p>获取了预构建的 hash 值后，让我退回到 optimizeDeps 函数中，继续往下看。</p><p>通过参数 force 来判断是否需要强制优化，如果不需要那就对比老 hash 值，如果相等就返回老的 metadata.json 文件内容。</p><p>最后处理.vite 文件夹，为后续做准备。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer.ts</span><br>...<br><span class="hljs-keyword">const</span> data: DepOptimizationMetadata = &#123;<br>    <span class="hljs-attr">hash</span>: mainHash, <span class="hljs-comment">//&quot;9a4fa980&quot;</span><br>    <span class="hljs-attr">browserHash</span>: mainHash, <span class="hljs-comment">//&quot;9a4fa980&quot;</span><br>    <span class="hljs-attr">optimized</span>: &#123;&#125;,<br>  &#125;;<br><br><br><span class="hljs-comment">// 是否强制预先优化 不管是否已经更改。</span><br><span class="hljs-comment">// force = config.server.force 来源于cli.ts，获取命令行参数中是否有 --force</span><br><span class="hljs-keyword">if</span> (!force) &#123;<br>  <span class="hljs-keyword">let</span> prevData;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 尝试解析已经存在的metadata数据， 获取/.vite/metadata.json中的内容</span><br>    prevData = <span class="hljs-built_in">JSON</span>.parse(fs.readFileSync(dataPath, <span class="hljs-string">&#x27;utf-8&#x27;</span>));<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;&#125;<br>  <span class="hljs-comment">// hash is consistent, no need to re-bundle</span><br>  <span class="hljs-comment">// 如果预dep数据的hash相同，那就直接跳过，如果需要覆盖就使用 --force</span><br>  <span class="hljs-keyword">if</span> (prevData &amp;&amp; prevData.hash === data.hash) &#123;<br>    log(<span class="hljs-string">&#x27;Hash is consistent. Skipping. Use --force to override.&#x27;</span>);<br>    <span class="hljs-keyword">return</span> prevData;<br>  &#125;<br>&#125;<br><span class="hljs-comment">//如果 node_modules/.vite 存在，那就清空。</span><br><span class="hljs-keyword">if</span> (fs.existsSync(cacheDir)) &#123;<br>  emptyDir(cacheDir);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 要不然就创建文件夹， 并且recursive：true 返回创建文件夹的路径</span><br>  fs.mkdirSync(cacheDir, &#123; <span class="hljs-attr">recursive</span>: <span class="hljs-literal">true</span> &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取需要编译依赖关系的模块路径"><a href="#获取需要编译依赖关系的模块路径" class="headerlink" title="获取需要编译依赖关系的模块路径"></a>获取需要编译依赖关系的模块路径</h3><p>解决.vite 文件夹后，我们跟着代码处理.vite 中的内容文件。</p><p>这边创建了两个变量 deps 和 missing。</p><p>deps: 需要处理依赖关系的路径对象。</p><p>missing: 需要处理依赖关系但在 node_modules 中没有找到来源的数组对象。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//deps</span><br>&#123;<br>  <span class="hljs-attr">&quot;vue&quot;</span>: <span class="hljs-string">&quot;/.../my-vue-app/node_modules/vue/dist/vue.runtime.esm-bundler.js&quot;</span>,<br>  <span class="hljs-attr">&quot;axios&quot;</span>: <span class="hljs-string">&quot;/.../my-vue-app/node_modules/axios/index.js&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>需要提前知道的是，newDeps 这个 args 参数区分了第一次编译和已启动后遇到新依赖关系导入重写运行的编译。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer.ts</span><br><br><span class="hljs-keyword">let</span> deps: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;, missing: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// 在服务器已经启动之后，如果遇到一个新的依赖关系导入，</span><br><span class="hljs-comment">// 而这个依赖关系还没有在缓存中，Vite 将重新运行依赖构建进程并重新加载页面。</span><br><span class="hljs-comment">// 如上官方文档所述，最终会得出deps 和missing</span><br><span class="hljs-keyword">if</span> (!newDeps) &#123;<br>  <span class="hljs-comment">// scanImports 这里就不展开了，他的作用就是获取导入源，用正则检测后，使用esbuild编译所有的入口依赖（entries)</span><br>  (&#123; deps, missing &#125; = <span class="hljs-keyword">await</span> scanImports(config));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  deps = newDeps;<br>  missing = &#123;&#125;;<br>&#125;<br><span class="hljs-comment">// 重写更新了浏览器的哈希</span><br><span class="hljs-comment">// update browser hash</span><br>data.browserHash = createHash(<span class="hljs-string">&#x27;sha256&#x27;</span>)<br>  .update(data.hash + <span class="hljs-built_in">JSON</span>.stringify(deps))<br>  .digest(<span class="hljs-string">&#x27;hex&#x27;</span>)<br>  .substr(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure><h3 id="没有找到来源的模块处理-missing"><a href="#没有找到来源的模块处理-missing" class="headerlink" title="没有找到来源的模块处理(missing)"></a>没有找到来源的模块处理(missing)</h3><p>下面代码很简单，处理在 node_modules 中没有找到来源的模块。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer.ts</span><br><br><span class="hljs-comment">// missing是一个储存需要处理依赖关系但在 node_modules 中没有找到来源的数组对象，如果有的话直接error提醒一波。</span><br><span class="hljs-keyword">const</span> missingIds = <span class="hljs-built_in">Object</span>.keys(missing);<br><span class="hljs-keyword">if</span> (missingIds.length) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<br>    <span class="hljs-string">`The following dependencies are imported but could not be resolved:\n\n  <span class="hljs-subst">$&#123;missingIds</span></span><br><span class="hljs-subst"><span class="hljs-string">      .map(</span></span><br><span class="hljs-subst"><span class="hljs-string">        (id) =&gt;</span></span><br><span class="hljs-subst"><span class="hljs-string">          <span class="hljs-string">`<span class="hljs-subst">$&#123;chalk.cyan(id)&#125;</span> <span class="hljs-subst">$&#123;chalk.white.dim(</span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">            <span class="hljs-string">`(imported by <span class="hljs-subst">$&#123;missing[id]&#125;</span>)`</span>,</span></span></span></span><br><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">          )&#125;</span>`</span>,</span></span><br><span class="hljs-subst"><span class="hljs-string">      )</span></span><br><span class="hljs-subst"><span class="hljs-string">      .join(<span class="hljs-string">`\n  `</span>)&#125;</span>\n\nAre they installed?`</span>,<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取并导入-自定义的强制预构建-include"><a href="#获取并导入-自定义的强制预构建-include" class="headerlink" title="获取并导入 自定义的强制预构建(include)"></a>获取并导入 自定义的强制预构建(include)</h3><p>接着处理在 vite.config.js 中 optimizeDeps.include。</p><p>如官方文档 API 所述，</p><p>optimizeDeps.include: 默认情况下，不在 node_modules 中的，链接的包不会被预构建。使用此选项可强制预构建链接的包</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer.ts</span><br><br><span class="hljs-comment">//config中是否有需要强制构建的依赖项, 处理后再deps中加入</span><br><span class="hljs-keyword">const</span> include = config.optimizeDeps?.include;<br><span class="hljs-keyword">if</span> (include) &#123;<br>  <span class="hljs-keyword">const</span> resolve = config.createResolver(&#123; <span class="hljs-attr">asSrc</span>: <span class="hljs-literal">false</span> &#125;);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">of</span> include) &#123;<br>    <span class="hljs-keyword">if</span> (!deps[id]) &#123;<br>      <span class="hljs-keyword">const</span> entry = <span class="hljs-keyword">await</span> resolve(id);<br>      <span class="hljs-keyword">if</span> (entry) &#123;<br>        deps[id] = entry;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<br>          <span class="hljs-string">`Failed to resolve force included dependency: <span class="hljs-subst">$&#123;chalk.cyan(id)&#125;</span>`</span>,<br>        );<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="命令行打印需要构建模块的信息"><a href="#命令行打印需要构建模块的信息" class="headerlink" title="命令行打印需要构建模块的信息"></a>命令行打印需要构建模块的信息</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer.ts</span><br><br><span class="hljs-keyword">const</span> qualifiedIds = <span class="hljs-built_in">Object</span>.keys(deps);<br><span class="hljs-comment">//不用说很简单，没有需要依赖的dep就跳过</span><br><span class="hljs-keyword">if</span> (!qualifiedIds.length) &#123;<br>  writeFile(dataPath, <span class="hljs-built_in">JSON</span>.stringify(data, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>));<br>  log(<span class="hljs-string">`No dependencies to bundle. Skipping.\n\n\n`</span>);<br>  <span class="hljs-keyword">return</span> data;<br>&#125;<br><br><span class="hljs-comment">// 这里也不用解释太多，基本上就是打印出信息的逻辑，然后绿色高亮告诉你要预缓存巴拉巴拉</span><br><span class="hljs-keyword">const</span> total = qualifiedIds.length;<br><span class="hljs-keyword">const</span> maxListed = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">const</span> listed = <span class="hljs-built_in">Math</span>.min(total, maxListed);<br><span class="hljs-keyword">const</span> extra = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, total - maxListed);<br><span class="hljs-keyword">const</span> depsString = chalk.yellow(<br>  qualifiedIds.slice(<span class="hljs-number">0</span>, listed).join(<span class="hljs-string">`\n  `</span>) +<br>    (extra &gt; <span class="hljs-number">0</span> ? <span class="hljs-string">`\n  (...and <span class="hljs-subst">$&#123;extra&#125;</span> more)`</span> : <span class="hljs-string">``</span>),<br>);<br><span class="hljs-keyword">if</span> (!asCommand) &#123;<br>  <span class="hljs-keyword">if</span> (!newDeps) &#123;<br>    <span class="hljs-comment">// This is auto run on server start - let the user know that we are</span><br>    <span class="hljs-comment">// pre-optimizing deps</span><br>    logger.info(<br>      chalk.greenBright(<span class="hljs-string">`Pre-bundling dependencies:\n  <span class="hljs-subst">$&#123;depsString&#125;</span>`</span>),<br>    );<br>    logger.info(<br>      <span class="hljs-string">`(this will be run only when your dependencies or config have changed)`</span>,<br>    );<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  logger.info(chalk.greenBright(<span class="hljs-string">`Optimizing dependencies:\n  <span class="hljs-subst">$&#123;depsString&#125;</span>`</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="创建预构建对象"><a href="#创建预构建对象" class="headerlink" title="创建预构建对象"></a>创建预构建对象</h3><p>使用 es-module-lexer 模块获取每个 deps 中的预构建模块文件，输出引入和导出的数据并保存。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer.ts</span><br><br><span class="hljs-keyword">import</span> &#123; ImportSpecifier, init, parse &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;es-module-lexer&#x27;</span>;<br><br><span class="hljs-comment">// esbuild generates nested directory output with lowest common ancestor base</span><br><span class="hljs-comment">// this is unpredictable and makes it difficult to analyze entry / output</span><br><span class="hljs-comment">// mapping. So what we do here is:</span><br><span class="hljs-comment">// 1. flatten all ids to eliminate slash</span><br><span class="hljs-comment">// 2. in the plugin, read the entry ourselves as virtual files to retain the</span><br><span class="hljs-comment">//    path.</span><br><span class="hljs-keyword">const</span> flatIdDeps: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt; = &#123;&#125;;<br><span class="hljs-keyword">const</span> idToExports: Record&lt;<span class="hljs-built_in">string</span>, ExportsData&gt; = &#123;&#125;;<br><span class="hljs-keyword">const</span> flatIdToExports: Record&lt;<span class="hljs-built_in">string</span>, ExportsData&gt; = &#123;&#125;;<br><span class="hljs-comment">// 运行es-module-lexer的初始化函数，后续会用到</span><br><span class="hljs-keyword">await</span> init;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> id <span class="hljs-keyword">in</span> deps) &#123;<br>  <span class="hljs-comment">// 替换id中的斜杠变成下划线 node/abc =&gt; node_abc</span><br>  <span class="hljs-keyword">const</span> flatId = flattenId(id);<br>  flatIdDeps[flatId] = deps[id];<br>  <span class="hljs-comment">// 获取每个依赖源的文件内容</span><br>  <span class="hljs-comment">//&#123; vue: &#x27;/.../my-vue-app/node_modules/vue/dist/vue.runtime.esm-bundler.js&#x27;,</span><br>  <span class="hljs-comment">// &#x27;element-plus&#x27;: &#x27;/.../my-vue-app/node_modules/element-plus/lib/index.esm.js&#x27;,</span><br>  <span class="hljs-comment">//  axios: &#x27;/.../my-vue-app/node_modules/axios/index.js&#x27; &#125;</span><br>  <span class="hljs-keyword">const</span> entryContent = fs.readFileSync(deps[id], <span class="hljs-string">&#x27;utf-8&#x27;</span>);<br>  <span class="hljs-comment">// parse出自es-module-lexer，这个包是一个js模块语法词法分析器，体积非常小</span><br>  <span class="hljs-comment">// 解析出后的ExportsData 是一个数组，[0]是imports, [1]是exports</span><br>  <span class="hljs-keyword">const</span> exportsData = parse(entryContent) <span class="hljs-keyword">as</span> ExportsData;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">    ss/se =&gt; statement start/end 缩写, &#123;number&#125; import的开始和结束index</span><br><span class="hljs-comment">    这里以vue举例，parse返回的值 =&gt;  ss = 0 se = 60</span><br><span class="hljs-comment">    entryContent.slice(0, 60) =&gt; &quot;import &#123; initCustomFormatter, warn &#125; from &#x27;@vue/runtime-dom&#x27;&quot;</span><br><span class="hljs-comment">    entryContent.slice(62, 94) =&gt; &quot;export * from &#x27;@vue/runtime-dom&quot;</span><br><span class="hljs-comment">    最后标注需要特殊处理的 export from</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> &#123; ss, se &#125; <span class="hljs-keyword">of</span> exportsData[<span class="hljs-number">0</span>]) &#123;<br>    <span class="hljs-keyword">const</span> exp = entryContent.slice(ss, se);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/export\s+\*\s+from/</span>.test(exp)) &#123;<br>      exportsData.hasReExports = <span class="hljs-literal">true</span>; <span class="hljs-comment">//待定</span><br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 分别记录以id flatId的exportsData</span><br>  <span class="hljs-comment">// exportsData数据太多这里就不贴了，总之里面包含每个构建模块中的import和export的数据。</span><br>  idToExports[id] = exportsData;<br>  flatIdToExports[flatId] = exportsData;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上述描述代码中，我们理一下当前的逻辑。</p><ol><li><p>获取了预构建模块的内容（hash 值，优化对象等）。</p></li><li><p>获取包管理器的 lockfile 转换的 hash 值，判断是否需要重新运行预构建。</p></li><li><p>获取需要编译依赖关系的模块路径（deps）和需要编译但没找到来源的模块（missing)。</p></li><li><p>处理 missing 数组，打印 error 提示是否已安装来源。</p></li><li><p>获取 vite.config.js 中自定义强制预构建的模块路径(include)，加入 deps 对象中。</p></li><li><p>命令行打印需要构建模块的信息。</p><p><img src="/images/pre-build.png" alt="pre-build"></p></li><li><p>创建预构建对象，获取预构建对象中的引入导出数据并记录。</p></li></ol><p><strong>处理完各种琐事之后，我们获取了需要构建的 deps 对象，接下来进入下一章节来解析 deps 对象。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>工程化</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite 依赖解析和预构建 源码分析 - (3)构建和插件</title>
    <link href="/2021/07/14/vite-3/"/>
    <url>/2021/07/14/vite-3/</url>
    
    <content type="html"><![CDATA[<h1 id="Vite-依赖解析和预构建-源码分析-3-构建和插件"><a href="#Vite-依赖解析和预构建-源码分析-3-构建和插件" class="headerlink" title="Vite 依赖解析和预构建 源码分析 - (3)构建和插件"></a>Vite 依赖解析和预构建 源码分析 - (3)构建和插件</h1><h3 id="构建-build"><a href="#构建-build" class="headerlink" title="构建(build)"></a>构建(build)</h3><p>需要注意的几个参数：</p><ol><li><p><code>format</code>设为<code>esm</code>，是 Vite 的目的之一，将所有的代码视为原生 ES 模块。</p><blockquote><p>CommonJS 和 UMD 兼容性: 开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。</p></blockquote></li><li><p><code>splitting</code>设为<code>true</code>，仅适用于 esm 输出下，拆分多个文件引入的模块至单独文件，浏览页面 a 时，加载了 axios，再进入页面 b 时，直接调用已经加载后的 axios，省去了再次请求 axios 的操作。</p><blockquote><p>Code shared between multiple entry points is split off into a separate shared file that both entry points import. That way if the user first browses to one page and then to another page, they don’t have to download all of the JavaScript for the second page from scratch if the shared part has already been downloaded and cached by their browser.</p></blockquote><blockquote><p>Code referenced through an asynchronous import() expression will be split off into a separate file and only loaded when that expression is evaluated. This allows you to improve the initial download time of your app by only downloading the code you need at startup, and then lazily downloading additional code if needed later.</p></blockquote></li><li><p><code>plugins</code>含有 Vite 插件<code>esbuildDepPlugin</code>: 下面会详细解释此插件。</p></li><li><p><code>treeShaking</code>设为<code>ignore-annotations</code>, 文档中提到的忽略无用的代码，以便减轻模块的体积。</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer/index.ts</span><br><br><span class="hljs-comment">// 最核心的地方，使用esBuild打包了</span><br><span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> build(&#123;<br>  <span class="hljs-attr">entryPoints</span>: <span class="hljs-built_in">Object</span>.keys(flatIdDeps),<br>  <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//任何导入的依赖一起打包</span><br>  <span class="hljs-attr">format</span>: <span class="hljs-string">&#x27;esm&#x27;</span>, <span class="hljs-comment">// 符合vite 转换成esm</span><br>  <span class="hljs-attr">external</span>: config.optimizeDeps?.exclude, <span class="hljs-comment">//不需要处理的模块</span><br>  <span class="hljs-attr">logLevel</span>: <span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-comment">//日志级别，只显示错误</span><br>  <span class="hljs-comment">//拆分代码，简单来说就是拆分入口内的共享import文件，在访问a页面时加载了axios，</span><br>  <span class="hljs-comment">//进入了b页面直接使用a页面加载的axios省去了再次请求的过程。</span><br>  <span class="hljs-attr">splitting</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">//这个不用多说哈</span><br>  <span class="hljs-attr">outdir</span>: cacheDir, <span class="hljs-comment">//vite自定义的默认缓存文件夹， node_modules/.vite</span><br>  <span class="hljs-comment">//修剪树枝？ 默认删除无用的代码，ignore-annotations的话指忽略那些删掉会损坏包的无用代码</span><br>  <span class="hljs-attr">treeShaking</span>: <span class="hljs-string">&#x27;ignore-annotations&#x27;</span>,<br>  <span class="hljs-attr">metafile</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 生成meta json</span><br>  define, <span class="hljs-comment">// 替换标识符</span><br>  <span class="hljs-attr">plugins</span>: [...plugins, esbuildDepPlugin(flatIdDeps, flatIdToExports, config)],<br>  ...esbuildOptions,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="esbuild-插件"><a href="#esbuild-插件" class="headerlink" title="esbuild 插件"></a>esbuild 插件</h3><p>了解 esbuild 的插件的可以直接跳过这节，此节简单解释了下插件的结构:</p><p>(1) esbuild plugin 是一个包含<code>name</code>和<code>setup</code>的对象结构。 <code>name</code>为插件名,<code>setup</code>是一个接收<code>build</code>的函数。</p><p>(2) 主要的逻辑在<code>setup</code>函数中，分别为<code>build.onResolve</code>和 <code>build.onLoad</code>。</p><p><code>build.onResolve</code>: 此函数拦截相应的导入路径，修改路径并标记特定的命名空间。</p><p><code>build.onLoad</code>: 此函数接收并筛选所有标记命名空间为<code>env-ns</code>的传入项,告诉 esbuild 该如何处理。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">let</span> envPlugin = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;env&#x27;</span>,<br>  <span class="hljs-function"><span class="hljs-title">setup</span>(<span class="hljs-params">build</span>)</span> &#123;<br>    <span class="hljs-comment">// 第一个参数为拦截规则。如下示例，用正则拦截了名为`env`的路径。</span><br>    <span class="hljs-comment">// 第二个参数为函数，返回对象中包含路径（这里可以对路径修改并返回）和标记`env-ns`命名空间。</span><br>    build.onResolve(&#123; <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/^env$/</span> &#125;, <span class="hljs-function">(<span class="hljs-params">args</span>) =&gt;</span> (&#123;<br>      <span class="hljs-attr">path</span>: args.path,<br>      <span class="hljs-attr">namespace</span>: <span class="hljs-string">&#x27;env-ns&#x27;</span>,<br>    &#125;));<br><br>    <span class="hljs-comment">// 第一个参数为接收命名空间为env-ns的路径并通过filter筛选。</span><br>    <span class="hljs-comment">// 第二个参数为函数，告诉esbuild在env-ns命名空间中要返回json格式的环境变量。</span><br>    build.onLoad(&#123; <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/.*/</span>, <span class="hljs-keyword">namespace</span>: &#x27;env-ns&#x27; &#125;, () =&gt; (&#123;<br>      <span class="hljs-attr">contents</span>: <span class="hljs-built_in">JSON</span>.stringify(process.env),<br>      <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>    &#125;));<br>  &#125;,<br>&#125;;<br><br><span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;esbuild&#x27;</span>)<br>  .build(&#123;<br>    <span class="hljs-attr">entryPoints</span>: [<span class="hljs-string">&#x27;app.js&#x27;</span>],<br>    <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">outfile</span>: <span class="hljs-string">&#x27;out.js&#x27;</span>,<br>    <span class="hljs-attr">plugins</span>: [envPlugin],<br>  &#125;)<br>  .catch(<span class="hljs-function">() =&gt;</span> process.exit(<span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><h3 id="esbuildDepPlugin"><a href="#esbuildDepPlugin" class="headerlink" title="esbuildDepPlugin"></a>esbuildDepPlugin</h3><p>首先需要看下 Vite 插件的一些用到的函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer/esbuildDepPlugin.ts</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">esbuildDepPlugin</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">  qualified: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">string</span>&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  exportsData: Record&lt;<span class="hljs-built_in">string</span>, ExportsData&gt;,</span></span><br><span class="hljs-params"><span class="hljs-function">  config: ResolvedConfig,</span></span><br><span class="hljs-params"><span class="hljs-function"></span>): <span class="hljs-title">Plugin</span></span>;<br></code></pre></td></tr></table></figure><h4 id="1-创建了两个解析器，分别对应-esm-和-commonjs。"><a href="#1-创建了两个解析器，分别对应-esm-和-commonjs。" class="headerlink" title="(1) 创建了两个解析器，分别对应 esm 和 commonjs。"></a>(1) 创建了两个解析器，分别对应 <code>esm</code> 和 <code>commonjs</code>。</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer/esbuildDepPlugin.ts</span><br><br><span class="hljs-comment">// default resolver which prefers ESM</span><br><span class="hljs-keyword">const</span> _resolve = config.createResolver(&#123; <span class="hljs-attr">asSrc</span>: <span class="hljs-literal">false</span> &#125;);<br><br><span class="hljs-comment">// cjs resolver that prefers Node</span><br><span class="hljs-keyword">const</span> _resolveRequire = config.createResolver(&#123;<br>  <span class="hljs-attr">asSrc</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">isRequire</span>: <span class="hljs-literal">true</span>,<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="2-创建-resolve-函数，主要用来解决判断是什么类型的模块，并且返回相应的解析器结果。"><a href="#2-创建-resolve-函数，主要用来解决判断是什么类型的模块，并且返回相应的解析器结果。" class="headerlink" title="(2) 创建 resolve 函数，主要用来解决判断是什么类型的模块，并且返回相应的解析器结果。"></a>(2) 创建 <code>resolve</code> 函数，主要用来解决判断是什么类型的模块，并且返回相应的解析器结果。</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer/esbuildDepPlugin.ts</span><br><br><span class="hljs-keyword">const</span> resolve = (<br>  id: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">importer</span>: <span class="hljs-built_in">string</span>,<br>  <span class="hljs-attr">kind</span>: ImportKind,<br>  resolveDir?: <span class="hljs-built_in">string</span>,<br>): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>&gt; =&gt; &#123;<br>  <span class="hljs-keyword">let</span> _importer;<br>  <span class="hljs-comment">// explicit resolveDir - this is passed only during yarn pnp resolve for</span><br>  <span class="hljs-comment">// entries</span><br>  <span class="hljs-comment">// 传如果传入文件夹，那就获取绝对路径的文件夹路径</span><br>  <span class="hljs-keyword">if</span> (resolveDir) &#123;<br>    _importer = normalizePath(path.join(resolveDir, <span class="hljs-string">&#x27;*&#x27;</span>));<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// map importer ids to file paths for correct resolution</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * mporter是否在外部传入的flatIdDeps中，</span><br><span class="hljs-comment">     * &#123;</span><br><span class="hljs-comment">     *  vue: &#x27;/Users/kev1nzh/Desktop/new/my-vue-app/node_modules/vue/dist/vue.runtime.esm-bundler.js&#x27;,</span><br><span class="hljs-comment">     *  axios: &#x27;/Users/kev1nzh/Desktop/new/my-vue-app/node_modules/axios/index.js&#x27;</span><br><span class="hljs-comment">     * &#125;</span><br><span class="hljs-comment">     * 如果在获取value的路径</span><br><span class="hljs-comment">     */</span><br>    _importer = importer <span class="hljs-keyword">in</span> qualified ? qualified[importer] : importer;<br>  &#125;<br>  <span class="hljs-comment">//判断是否时以require开头，为了筛选出 kind为require-resolve, require-call的模块，调用resolveRequire</span><br>  <span class="hljs-keyword">const</span> resolver = kind.startsWith(<span class="hljs-string">&#x27;require&#x27;</span>) ? _resolveRequire : _resolve;<br>  <span class="hljs-comment">// 返回解决完的路径,这个函数的代码后续会有章节详细讲</span><br>  <span class="hljs-keyword">return</span> resolver(id, _importer);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="3-创建resolveEntry函数，根据传入类型返回命名空间。"><a href="#3-创建resolveEntry函数，根据传入类型返回命名空间。" class="headerlink" title="(3) 创建resolveEntry函数，根据传入类型返回命名空间。"></a>(3) 创建<code>resolveEntry</code>函数，根据传入类型返回命名空间。</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveEntry</span>(<span class="hljs-params">id: <span class="hljs-built_in">string</span>, isEntry: <span class="hljs-built_in">boolean</span>, resolveDir: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> flatId = flattenId(id);<br>  <span class="hljs-keyword">if</span> (flatId <span class="hljs-keyword">in</span> qualified) &#123;<br>    <span class="hljs-keyword">return</span> isEntry<br>      ? &#123;<br>          <span class="hljs-attr">path</span>: flatId,<br>          <span class="hljs-attr">namespace</span>: <span class="hljs-string">&#x27;dep&#x27;</span>,<br>        &#125;<br>      : &#123;<br>          <span class="hljs-attr">path</span>: <span class="hljs-built_in">require</span>.resolve(qualified[flatId], &#123;<br>            <span class="hljs-attr">paths</span>: [resolveDir],<br>          &#125;),<br>        &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-Vite-的onResolve"><a href="#4-Vite-的onResolve" class="headerlink" title="(4) Vite 的onResolve"></a>(4) Vite 的<code>onResolve</code></h4><p>Vite 创建了两个<code>onResolve</code>， 一个处理 js 文件，一个处理非 js 类型的文件。</p><p>处理非 js：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer/esbuildDepPlugin.ts</span><br><br><span class="hljs-comment">// 这个onResolve为处理非js类型的文件</span><br><br><span class="hljs-comment">// 非js类型的文件数组</span><br><span class="hljs-keyword">const</span> externalTypes = [<br>  <span class="hljs-string">&#x27;css&#x27;</span>,<br>  <span class="hljs-string">&#x27;less&#x27;</span>,<br>  <span class="hljs-string">&#x27;sass&#x27;</span>,<br>  ...<br>];<br>build.onResolve(<br>  &#123;<br>    <span class="hljs-comment">// 这边通过正则匹配出在externalTypes数组内格式的文件</span><br>    <span class="hljs-attr">filter</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">`\\.(`</span> + externalTypes.join(<span class="hljs-string">&#x27;|&#x27;</span>) + <span class="hljs-string">`)(\\?.*)?$`</span>),<br>  &#125;,<br>  <span class="hljs-keyword">async</span> (&#123; <span class="hljs-attr">path</span>: id, importer, kind &#125;) =&gt; &#123;<br>    <span class="hljs-comment">// importer &#123;string&#125; 要打包的导入模块路径</span><br>    <span class="hljs-comment">// kind &#123;string&#125; 导入规则 | &#x27;entry-point&#x27;| &#x27;import-statement&#x27;| &#x27;require-call&#x27;| &#x27;dynamic-import&#x27;| &#x27;require-resolve&#x27;| &#x27;import-rule&#x27;| &#x27;url-token&#x27;</span><br>    <span class="hljs-keyword">const</span> resolved = <span class="hljs-keyword">await</span> resolve(id, importer, kind);<br>    <span class="hljs-keyword">if</span> (resolved) &#123;<br>      <span class="hljs-comment">// 返回标记特殊处理，并返回引入文件的路径</span><br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">path</span>: resolved,<br>        <span class="hljs-attr">external</span>: <span class="hljs-literal">true</span>,<br>      &#125;;<br>    &#125;<br>  &#125;,<br>);<br></code></pre></td></tr></table></figure><p>处理 js 类型的文件:</p><p>以下代码就是 Vite 最刺激的地方，我应该会新建一篇章节来解释这块代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// /optimizer/esbuildDepPlugin.ts</span><br><br><span class="hljs-comment">// 这个onResolve为处理js类型的文件</span><br><br>build.onResolve(<br>  &#123; <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/^[\w@][^:]/</span> &#125;,<br>  <span class="hljs-keyword">async</span> (&#123; <span class="hljs-attr">path</span>: id, importer, kind, resolveDir &#125;) =&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      id:  vue</span><br><span class="hljs-comment">      importer:</span><br><span class="hljs-comment">      kind:  entry-point</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      id:  <span class="hljs-doctag">@vue</span>/runtime-dom</span><br><span class="hljs-comment">      importer:  /Users/kev1nzh/Desktop/new/my-vue-app/node_modules/vue/dist/vue.runtime.esm-bundler.js</span><br><span class="hljs-comment">      kind:  import-statement</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      参数如上，vite把预打包的模块分为 入口模块和依赖模块，</span><br><span class="hljs-comment">      像axios vue之类的 我们在项目中import的模块，</span><br><span class="hljs-comment">      runtime-dom 这种模块则是在package-lock.json, 是项目中入口模块的依赖模块，</span><br><span class="hljs-comment">      然后经过以下代码来区分并处理。</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">const</span> isEntry = !importer;<br>    <span class="hljs-comment">// ensure esbuild uses our resolved entries</span><br>    <span class="hljs-keyword">let</span> entry;<br>    <span class="hljs-comment">// if this is an entry, return entry namespace resolve result</span><br>    <span class="hljs-comment">// 如果他是入口，就返回名为dep的命名空间来做接下来操作</span><br>    <span class="hljs-keyword">if</span> ((entry = resolveEntry(id, isEntry, resolveDir))) <span class="hljs-keyword">return</span> entry;<br><br>    <span class="hljs-comment">// check if this is aliased to an entry - also return entry namespace</span><br>    <span class="hljs-keyword">const</span> aliased = <span class="hljs-keyword">await</span> _resolve(id, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (aliased &amp;&amp; (entry = resolveEntry(aliased, isEntry, resolveDir))) &#123;<br>      <span class="hljs-keyword">return</span> entry;<br>    &#125;<br><br>    <span class="hljs-comment">// use vite&#x27;s own resolver</span><br>    <span class="hljs-comment">// ok这里开始处理依赖模块的流程，这边resolve</span><br>    <span class="hljs-keyword">const</span> resolved = <span class="hljs-keyword">await</span> resolve(id, importer, kind);<br>    <span class="hljs-keyword">if</span> (resolved) &#123;<br>      <span class="hljs-comment">// vite自定义的id const browserExternalId = &#x27;__vite-browser-external&#x27;</span><br>      <span class="hljs-comment">// 返回命名空间和id，因为浏览器兼容问题，无法处理的忽略模块</span><br>      <span class="hljs-keyword">if</span> (resolved.startsWith(browserExternalId)) &#123;<br>        <span class="hljs-comment">//返回给browser-external命名空间处理并返回id</span><br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">path</span>: id,<br>          <span class="hljs-attr">namespace</span>: <span class="hljs-string">&#x27;browser-external&#x27;</span>,<br>        &#125;;<br>      &#125;<br>      <span class="hljs-comment">// 是否是非js或者外部文件，和上一个onResolve一样返回处理</span><br>      <span class="hljs-keyword">if</span> (isExternalUrl(resolved)) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">path</span>: resolved,<br>          <span class="hljs-attr">external</span>: <span class="hljs-literal">true</span>,<br>        &#125;;<br>      &#125;<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">path</span>: path.resolve(resolved),<br>      &#125;;<br>    &#125;<br>  &#125;,<br>);<br></code></pre></td></tr></table></figure><h4 id="5-Vite-的onLoad"><a href="#5-Vite-的onLoad" class="headerlink" title="(5) Vite 的onLoad"></a>(5) Vite 的<code>onLoad</code></h4><p><code>dep</code>命名空间处理,下面代码有点复杂，简单说下逻辑。</p><p>第一步，获取每个入口模块的引入路径，例如<code>axios</code>的<code>entryFile</code>为<code>/.../my-vue-app/node_modules/axios/index.js</code>,</p><p>转换成路径<code>relativePath</code>并添加前缀<code>node_modules/axios/index.js</code>。</p><p>第二步，根据<code>exportsData</code>（之前 parse 后返回出的引入和导出的数据）来判断<code>commonjs、default、export from</code>类型，</p><p>最后转换成<code>contents</code> =&gt; <code>export default require(&quot;./node_modules/axios/index.js&quot;)</code>。</p><p>第三步，根据入口模块的路径获取后缀<code>ext</code>。</p><p>最后返回对象。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * loader &#123;string&#125; 告诉esbuild要解析成js/css/....</span><br><span class="hljs-comment"> * resolveDir &#123;string&#125; 模块导入路径</span><br><span class="hljs-comment"> * contents: &#123;string&#125; 加载内容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> &#123;<br>  <span class="hljs-attr">loader</span>: ext <span class="hljs-keyword">as</span> Loader,<br>  contents,<br>  <span class="hljs-attr">resolveDir</span>: root,<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// 获取项目的路径</span><br><span class="hljs-keyword">const</span> root = path.resolve(config.root);<br>build.onLoad(&#123; <span class="hljs-attr">filter</span>: <span class="hljs-regexp">/.*/</span>, <span class="hljs-keyword">namespace</span>: &#x27;dep&#x27; &#125;, (&#123; path: id &#125;) =&gt; &#123;<br>  <span class="hljs-comment">// 入口文件 vue =&gt; /.../my-vue-app/node_modules/vue/dist/vue.runtime.esm-bundler.js</span><br>  <span class="hljs-keyword">const</span> entryFile = qualified[id];<br>  <span class="hljs-comment">// 获取原始路径</span><br>  <span class="hljs-keyword">let</span> relativePath = normalizePath(path.relative(root, entryFile));<br>  <span class="hljs-comment">// 这边来处理 .abc.js =&gt; ./abc.js</span><br>  <span class="hljs-keyword">if</span> (!relativePath.startsWith(<span class="hljs-string">&#x27;.&#x27;</span>)) &#123;<br>    relativePath = <span class="hljs-string">`./<span class="hljs-subst">$&#123;relativePath&#125;</span>`</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">let</span> contents = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">const</span> data = exportsData[id];<br>  <span class="hljs-keyword">const</span> [imports, <span class="hljs-built_in">exports</span>] = data;<br>  <span class="hljs-comment">// 下面都是处理不同模块的流程</span><br>  <span class="hljs-keyword">if</span> (!imports.length &amp;&amp; !<span class="hljs-built_in">exports</span>.length) &#123;<br>    <span class="hljs-comment">// cjs</span><br>    <span class="hljs-comment">// export default require(&quot;./node_modules/axios/index.js&quot;);</span><br>    contents += <span class="hljs-string">`export default require(&quot;<span class="hljs-subst">$&#123;relativePath&#125;</span>&quot;);`</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">exports</span>.includes(<span class="hljs-string">&#x27;default&#x27;</span>)) &#123;<br>      <span class="hljs-comment">// default</span><br>      <span class="hljs-comment">// import d from &quot;./node_modules/element-plus/lib/index.esm.js&quot;;export default d;</span><br>      contents += <span class="hljs-string">`import d from &quot;<span class="hljs-subst">$&#123;relativePath&#125;</span>&quot;;export default d;`</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (data.hasReExports || <span class="hljs-built_in">exports</span>.length &gt; <span class="hljs-number">1</span> || <span class="hljs-built_in">exports</span>[<span class="hljs-number">0</span>] !== <span class="hljs-string">&#x27;default&#x27;</span>) &#123;<br>      <span class="hljs-comment">// hasReExports</span><br>      <span class="hljs-comment">// export * from &quot;./node_modules/vue/dist/vue.runtime.esm-bundler.js&quot;</span><br>      contents += <span class="hljs-string">`\nexport * from &quot;<span class="hljs-subst">$&#123;relativePath&#125;</span>&quot;`</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 获取入口文件的后缀</span><br>  <span class="hljs-keyword">let</span> ext = path.extname(entryFile).slice(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (ext === <span class="hljs-string">&#x27;mjs&#x27;</span>) ext = <span class="hljs-string">&#x27;js&#x27;</span>;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * loader &#123;string&#125; 告诉esbuild要解析成js/css/....</span><br><span class="hljs-comment">   * resolveDir &#123;string&#125; 模块导入路径</span><br><span class="hljs-comment">   * contents: &#123;string&#125; 加载内容</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * 以下是一个处理vue runtime-dom的例子</span><br><span class="hljs-comment">   * &#123;</span><br><span class="hljs-comment">   *  ext: &#x27;js&#x27;,</span><br><span class="hljs-comment">   *  contents: &quot;export * from &quot;./node_modules/vue/dist/vue.runtime.esm-bundler.js&quot;,</span><br><span class="hljs-comment">   *  resolveDir: &#x27;..../node_modules/vue/dist&#x27;</span><br><span class="hljs-comment">   * &#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">loader</span>: ext <span class="hljs-keyword">as</span> Loader,<br>    contents,<br>    <span class="hljs-attr">resolveDir</span>: root,<br>  &#125;;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><p>上一章节<a href="/docs/rebuild/optimizer">预构建对象和前期准备</a>中获取<code>deps</code>对象后，调用<code>esbuild</code>的打包功能。</p></li><li><p>传入<code>Vite</code>自定义的插件中，以文件类型分类。</p></li><li><p> 告诉 esbuild 分为入口模块和依赖模块并处理，最终打包文件写入至<code>/node_modules/.vite</code>文件夹中。</p></li></ol><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>Vite 项目(Vue)中的<code>axios</code>编译走向如下：</p><h4 id="1-Vue-项目组件中引入axios"><a href="#1-Vue-项目组件中引入axios" class="headerlink" title="1. Vue 项目组件中引入axios"></a>1. Vue 项目组件中引入<code>axios</code></h4><p><img src="/images/build/1.png" alt="pre-build"></p><h4 id="2-vite-文件中的axios-js文件，已经编译成上一节中contents的路径了。"><a href="#2-vite-文件中的axios-js文件，已经编译成上一节中contents的路径了。" class="headerlink" title="2. .vite 文件中的axios.js文件，已经编译成上一节中contents的路径了。"></a>2. .vite 文件中的<code>axios.js</code>文件，已经编译成上一节中<code>contents</code>的路径了。</h4><p><img src="/images/build/3.png" alt="pre-build"></p><h3 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h3><p>所有依赖模块构建完毕后写入<code>/node_modules/.vite</code>文件中，如若依赖项新增或改变，则会重写构建<code>.vite</code>。每次启动项目时，如果有预构建文件，可以直接启动，不需要每次重写打包依赖项。</p><p><code>ECMA Script Modules(esm)</code>, 虽然 2021 年了，很多前端都已经在用最新的技术和代码来做项目，但是还有很多很多很多非常好用的模块都是好几年前创建的，那些模块导出机制五花八门，由<code>Vite</code>统一转换成 esm 的方式，只提供源码，让浏览器接管了打包这一服务。当页面需要某个模块时，Vite 只要转换并返回 esm 方式的源码就行了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>工程化</tag>
      
      <tag>Vite</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Start</title>
    <link href="/2021/07/13/Start/"/>
    <url>/2021/07/13/Start/</url>
    
    <content type="html"><![CDATA[<p>“你在打牌的时候，即便你抓到一副最烂的牌，你也不能弃局你也得把这个牌打完。我们很多时候是不是觉得我们抓的牌实在是太差了呀，但是再差的牌你也应该打下去。</p><p>有的时候我们惊奇地发现，再烂的牌我们打到最后还赢了，有没有这种可能。有的时候抓到一手好牌，你觉得你会赢反而输了。我们登上并非我们所选择的舞台，演出并非我们所选择的剧本。在座的有哪个同学是自愿来到这个世界上的，其实没有。我们登上并非我们选择的舞台。在座的有谁的剧本是你自己设定的。其实不是的。仔细想一想，我们这一生中其实自己能够决定的东西很少，我们可能能决定百分之五的东西，但是百分之九十五的东西是我们决定不了的。我们决定不了我们的出身，决定不了我们的智商，我们更决定不了我们这一生的贵人相助。</p><p>很多时候我们会羡慕别人的剧本，我有时候也会羡慕别人的剧本。但是没有谁的剧本值得羡慕，你只能把自己的剧本演好。如果在你的一生中，真的遭遇到这些挫折，那么对不起，这就是你的剧本。你有两种选择，一种是选择弃演，一种是把既定的剧本给选好、给演好。希望大家演好自己的剧本。”</p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
